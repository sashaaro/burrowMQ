use std::io::Read;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::net::TcpListener;
use tokio::time::sleep;

use amq_protocol::frame::{AMQPFrame, gen_frame};
use amq_protocol::protocol::AMQPClass;
use amq_protocol::protocol::connection::{gen_start, AMQPMethod, Start};
use amq_protocol::types::{FieldTable, LongString};
use bytes::BytesMut;

pub struct BurrowMQServer {
    // ...
}

const PROTOCOL_HEADER: &[u8] = b"AMQP\x00\x00\x09\x01";


/// AMQP Frame Types
// #[repr(u8)]
// #[derive(Clone, Copy)]
// pub enum FrameType {
//     Method = 1,
//     Header = 2,
//     Body = 3,
//     Heartbeat = 4,
// }
// 
// pub struct Frame {
//     pub frame_type: FrameType,
//     pub channel: u16,
//     pub payload: Vec<u8>,
// }

// impl Frame {
//     pub fn to_bytes(&self) -> Vec<u8> {
//         let mut buf: Vec<u8> = Vec::new();
// 
//         // Frame header
//         buf.push(self.frame_type as u8);                 // frame type
//         buf.extend(&self.channel.to_be_bytes());         // channel
//         buf.extend(&(self.payload.len() as u32).to_be_bytes()); // payload size
// 
//         // Payload
//         buf.extend(&self.payload);
// 
//         // Frame end
//         buf.push(0xCE);
// 
//         buf
//     }
// }

fn build_connection_start_payload() -> Vec<u8> {
    let mut payload = Vec::new();

    let class_id: u16 = 10;
    let method_id: u16 = 10;

    payload.extend(&class_id.to_be_bytes());      // Connection class
    payload.extend(&method_id.to_be_bytes());     // Start method
    payload.push(0); // version-major
    payload.push(9); // version-minor

    // server-properties — пока пустая field table
    payload.extend(&[0, 0, 0, 0]);

    // mechanisms = "PLAIN"
    payload.push(5);
    payload.extend(b"PLAIN");

    // locales = "en_US"
    payload.push(5);
    payload.extend(b"en_US");

    payload
}

impl BurrowMQServer {
    pub fn new() -> Self {
        Self {}
    }

    pub async fn start_forever(&mut self) -> anyhow::Result<()> {
        let listener = TcpListener::bind("127.0.0.1:5672").await?;
        println!("Listening on 127.0.0.1:5672");

        loop {
            let (mut socket, addr) = listener.accept().await?;
            println!("New client from {:?}", addr);

            tokio::spawn(async move {
                let mut buf = [0u8; 1024];
                loop {
                    match socket.read(&mut buf).await {
                        Ok(n) if n == PROTOCOL_HEADER.len() && buf[..PROTOCOL_HEADER.len()].eq(PROTOCOL_HEADER) => {
                            let payload = build_connection_start_payload();

                            let frame = Frame {
                                frame_type: FrameType::Method,
                                channel: 0,
                                payload,
                            };
                            //sleep(std::time::Duration::from_millis(2000)).await;
                            let b = frame.to_bytes();
                            // let _ = socket.write_all(&b).await;

                            let start = Start {
                                version_major: 0,
                                version_minor: 9,
                                server_properties: FieldTable::default(), // можно добавить info о сервере
                                mechanisms: LongString::from("PLAIN"),
                                locales: LongString::from("en_US"),
                            };



                            let amqp_frame  = AMQPFrame::Method(0, AMQPClass::Connection(AMQPMethod::Start(start)));

                            let mut buffer = vec![0u8; 30];
                            gen_frame(&amqp_frame)(buffer.as_mut_slice().into()).unwrap();
                            let _ = socket.write_all(&buffer).await;
                        }
                        Ok(n) if n > 0 => {
                            println!("Received: {:?}", &buf[..n]);

                            let _ = socket.write_all(b"AMQP\x00\x00\x09\x01").await; // ответ-банан
                        }
                        _ => {
                            println!("Connection closed or failed");
                            break
                        }
                    }
                }


                println!("12312321");
                sleep(std::time::Duration::from_millis(20)).await;
            });
        }
    }
}
